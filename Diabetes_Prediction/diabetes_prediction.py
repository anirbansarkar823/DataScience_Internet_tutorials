# -*- coding: utf-8 -*-
"""Diabetes Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E3C_LZH6SNPIhNhj14Rpl7wg_QZGSD2A

[tutorial](https://www.youtube.com/watch?v=xUE7SjVx9bQ&list=PLfFghEzKVmjvuSA67LszN1dZ-Dd_pkus6&index=2)
"""

#Importing the required libraries
import numpy as np
import pandas as pd

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn import svm

from sklearn.metrics import accuracy_score #as it is classification model

from google.colab import drive
drive.mount('/content/drive')

# Dataset - PIMA Diabetes Dataset

# loading the data
diabetes_data = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/diabetes.csv")

# to get help for a function
pd.read_csv?

diabetes_data.head()
# holds data for only females
# 1 - The patient is diabetic
# 0 - The patient is non-diabetic

# number of rows and columns
diabetes_data.shape

diabetes_data.columns

# getting the statistical measures
diabetes_data.describe()

# the ratio-split of target variable
diabetes_data.Outcome.value_counts()
# the data is skewed towards non-diabetic patients
# 1 - Diabetic Patient
# 0 - Non-Diabetic Patient

# finding mean based on target variable
diabetes_data.groupby('Outcome').mean()

# separating x and y
X = diabetes_data.drop(columns='Outcome', axis=1, inplace=False)
Y = diabetes_data['Outcome']
type(Y)

print(X) # features
print(Y) # labels

# Data standardization
scalar = StandardScaler()

scalar.fit(X) #fitting the standard scaler on whole data set

# Now transforming
standardized_data = scalar.transform(X)

standardized_df = pd.DataFrame(standardized_data, index=X.index, columns = X.columns)
standardized_df.head()

standardized_df.index

standardized_X = standardized_df
Y = diabetes_data['Outcome']

# spliting data into train-test data
X_train, X_test, y_train, y_test = train_test_split(standardized_X, Y, test_size=0.2, stratify=Y, random_state=2)
# if stratify is None, there might be a possibility that all the 'N' classes might to to test set
# to make an even distribution of data, we must set stratify = Y
# anyone setting random_state=2 will get the same portion of code iin splits

# help on train_test_split
train_test_split?

# lets see the split
print(standardized_X.shape, X_train.shape, X_test.shape)

classifier = svm.SVC(kernel='linear')
classifier

# help of support vector machine
svm.SVC?

# training the SVM Classifier
classifier.fit(X_train, y_train)

# Evaluating the model on train data itself
train_prediction = classifier.predict(X_train)
training_accuracy = accuracy_score(train_prediction, y_train)
print(f"accuracy score on training data {training_accuracy}")

# Evaluating the model on test data
test_prediction = classifier.predict(X_test)
test_accuracy = accuracy_score(test_prediction, y_test)
print(f"accuracy score on test data {test_accuracy}")

input_data = (3,78,50,32,88,31, 0.248,26)
type(input_data)

# changing the data from tuple to numpy array
np_input = np.array(input_data)
type(np_input)
np_input.shape # (8,) ==> but we need just 1 row

# Need to shape the array for predicting just one example
np_input_reshaped = np_input.reshape(1,-1)
np_input_reshaped.shape

# to make our model capable of predicting this example, we must standardize the data
np_input_standardized = scalar.transform(np_input_reshaped)
print(np_input_standardized)

# Now let us make the prediction
prediction = classifier.predict(np_input_standardized)
print(prediction) #the model has predicted the person as non-diabetic


# printting the label
if prediction[0] == 0: #prediction is list
  print("non-diabetic")
else:
  print("diabetic")